

//Margins, height and width for the chart group, which is appended to our SVG below.
var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = $(".chart").width() - margin.left - margin.right,
    height = $(".chart").height() - margin.top - margin.bottom;

//This is where we convert our date string to a JavaScript readable format.
//In order to determine the domain of our time scale, the date needs to be expressed as a number
//The domain will be the earliest and latest dates in our set.
//To learn more, check out the documentation:
//https://github.com/mbostock/d3/wiki/Time-Formatting
var parseDate = d3.time.format("%Y").parse;

//x and y are functions to which we feed invidual values...
//...in order to convert them to pixel locations on our chart.
//Each has three main properties:
//  1) type (domain, linear, ordinal, etc)
//  2) range (lowest and highest possible PIXEL location)
//  3) domain (lowest and highest possible value)
var x = d3.time.scale()
    .range([0, width]);

var y = d3.scale.linear()
    .range([height, 0]);


//xAxis and yAxis draw the axis on our chart
//Axis have ticks and labels that correspond to our data, so they depend on the x and y scale
//Hence, the scale(x) and scale(y) properties  
var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");

//The tickFormat method allows us to express each with one decimal point: d.toFixed(1)
//And to add a percent sign to the values.
var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .tickFormat(function(d) {
    	return String(d.toFixed(3)).replace("0.", ".");
    })

//The line function generates a path on our chart.
//Paths are expressed as a series of x,y coordinates...
//...so we use the x and y functions above to generate a x,y for each data point (date and AVG)
var line = d3.svg.line()
    .x(function(d) {
    	return x(d.date);
    })
    .y(function(d) {
    	return y(d.AVG);
    });


//This is where we append the SVG element to our page.
//Note that we append it to the .chart div, not the body, which is in most d3 examples
//We use the margin convention to offset the chart group from the outer SVG.
//You can read more about the margin convention here: http://bl.ocks.org/mbostock/3019563
var svg = d3.select(".chart").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

//Our ajax call uses the json method because we're loading json data
d3.json("js/baseballcard.json", function(error, data) {
  
  var stats = data.stats;

  //For each element in our dataset, use parseDate (above) to convert the date to a javascript-readable date.
  stats.forEach(function(d) {
    d.date = parseDate(d.year);
  });


  //We defined x and y above, but we didn't yet know the domain of our data
  //Because we hadn't loaded it yet. Now that we have it, we can set the domain for each.
  x.domain(d3.extent(stats, function(d) { return d.date; }));
  y.domain(d3.extent(stats, function(d) { return d.AVG; }));

  //The x axis is called with in a "g" element.
  //The translate property is what we use to pass x,y positions to "g" elements
  //So the x axis will appear 0 pixels from the left of the chart edge...
  //...and 500 (value of 'height') pixels from the top
  svg.append("g")  
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);

  //Call the y axis in a "g" element.
  //Appears 0 pixels from the left and top by default, so no need for translate property
  //We append a text label to the axis group.
  //We rotate it with the transform property.
  svg.append("g")
      .attr("class", "y axis")
      .call(yAxis)
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text("Batting Average");

  //This is where we draw our line.
  //Our line appears as a 'path' element with an attribute of 'd'
  //The 'd' attribute contains the point-to-point instructions for where our line should appear
  //Those instructions are generated by the line function above
  //To read more about svg lines and how they're drawn, go here: http://www.w3schools.com/svg/svg_path.asp
  svg.append("path")
      .datum(stats)
      .attr("class", "line")
      .attr("d", line);

  //Here, we draw our dots. We'll draw one for each element in our data array.
  //We begin by selecting all of the .dot elements, which don't exist yet.
  svg.selectAll(".dot")
    //Then we introduce our data: .data(data)
    //And insert it into our selection: .enter()
  	.data(stats)
  	.enter()
    //For each data point, append a 'circle' element
  	.append("circle")
    .attr("class", "dot")
    //Circles have x,y positions expressed as cx and cy. 'c' stands for center.
  	.attr("cx", function(d) {
  		return x(d.date);
  	})
  	.attr("cy", function(d) {
  		return y(d.AVG);
  	})
    //"r" is the radius of the circle
  	.attr("r", 5)
    //We apply 3 event listeners: "mouseover", "mouseout", and "mousemove".
    //Mouseover is where we pull in the data attached to each circle
    //That appears as "d" in the function(d) line...
    //...and contains the attributes we want to surface
  	.on("mouseover", function(d) {	
      //We used the moment() method to create a date string
      //Moment comes from the moment.js library, which we're loading in our index.html page
  		//var dispDate = moment(d.date).format("MMM. D, YYYY");
  		
      var yearFormat = d3.time.format("%Y");
      var dispDate = yearFormat(d.date);

      var dispAvg = String(d.AVG.toFixed(3)).replace("0.", ".");

      //var dayNameFormat = d3.time.format("%A");

      // .tt is the class of a div we've added to our chart in the index.html file
      // .tt is where we put our date and unemployment data to be displayed
      $(".tt").html(
  			"<div class='date'>"+dispDate+"</div>"+
  			"<div class='val'>"+dispAvg+"</div>"
  		);

      //Adding .active class to this circle so it turns red.
      //The fill color for .dot.active is set in style.css
      d3.select(this).classed("active", true);

      //In the css, .tt has a 'display' property set to 'hidden'. This keeps it from showing up on page load.
      //When we roll over it, we use the show() method to see it.
  		$(".tt").show();
  	})
    //On 'mouseout', we hide the tooltip again.
  	.on("mouseout", function(d) {

      //Remoing .active class to this circle so it turns back to blue.
      d3.select(this).classed("active", false);
  		
      $(".tt").hide();
  	})
    //And on 'mousemove', we calculate the position where we want the tooltip to show up.
    //The position is dependent on the position of the mouse.
  	.on("mousemove", function(d) {
  		//pos is equal to the mouse position.
      //It shows up as a two value array [x, y]
      var pos = d3.mouse(this);
  	
      //Here we do some math to get the tooltip to show up where we want it...
      //...in relation to the mouse
      //we add margin.left + 15 to account for the chart 'g' margin and the padding of the .chart div.
  		var left = pos[0] + margin.left + 15 - ($(".tt").outerWidth()/2);

      //Here we add the top margin and subtract the height of the tooltip so it displays above our mouse
  		var top = pos[1] + margin.top - $(".tt").height() - 30;

      //With our two positions defined, we now apply them to our tooltip with the jQuery css method.
  		$(".tt").css({
  			"left" : left+"px",
  			"top" : top+"px"
  		});

  	});





});
